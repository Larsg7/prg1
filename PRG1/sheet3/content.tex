\section*{3.1}
\subsection*{(a)}
\subsubsection*{$1234_{10}$}
\begin{enumerate}
	\item \textbf{Basis 2:}\\
	$1234 / 2 = 617 \text{R} 0$\\
	$617 / 2 = 308 \text{R} 1$\\
	$308 / 2 = 154 \text{R} 0$\\ 
	$154 / 2 = 77 \text{R} 0$\\
	$77 / 2 = 38 \text{R} 1$\\
	$38 / 2 = 19 \text{R} 0$\\
	$19 / 2 = 9 \text{R} 1$\\
	$9 / 2 = 4 \text{R} 1$\\
	$4 / 2 = 2 \text{R} 0$\\
	$2 / 2 = 1 \text{R} 0$\\
	$1 / 2 = 0 \text{R} 1$\\
	$\rightarrow 1234_{10} = 0000\ 0100\ 1101\ 0010_2$
	\item \textbf{Basis 16:}\\
	Von Binär nach Hexadecimal:\\
	$0010_2 = 2_{16}$\\
	$1101_2 = D_{16}$\\
	$0100_2 = 4_{16}$\\
	$\rightarrow 1234_{10} = 4D2_{16}$
\end{enumerate}
\subsubsection*{$CAFE_{16}$}
\begin{enumerate}
\item \textbf{Basis 2:}\\
$C_{16} = 1100_2$\\
$A_{16} = 1010_2$\\
$F_{16} = 1111_2$\\
$E_{16} = 1110_2$\\
$\rightarrow CAFE_{16} = 1100\ 1010\ 1111\ 1110_2$
\item \textbf{Basis 10:}\\
$CAFE_{16} = 12 * 16^3 + 10 * 16^2 + 15 * 16 + 14 = 51966_{10}$
\end{enumerate}

\subsection*{(b)}
\begin{enumerate}
\item \textbf{-128}\\
Die Zahl kann nicht mit 8-bit im Einerkomplement dargestellt werden. Die kleinste mögliche Zahl ist -127.
\item \textbf{-1}\\
$-1_{10} = 1000\ 0001_2$
\item \textbf{-1}\\
$-127_{10} = 1111\ 1111_2$
\end{enumerate}
\subsection*{(c)}
$127_{10} = 0111\ 1111_2$ im Zweierkomplement. Addiert man 1 ergibt sich $1000\ 0000_2$ im Zweierkomplement, was der Zahl $-128_{10}$ entspricht. Es kommt also zum Integeroverflow von der größst möglichen Zahl hin zur kleinsten Zahl.

\section*{3.2}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Binär im ZK (16bit) & Oktal (Oktal im ZK) & Dezimal (Dezimal im ZK) \\\hline\hline
0110 0110 1010 0110 & 63246 (63246) & 26278 (26278) \\\hline
1011 1111 0000 0000 & -40400 (37378) & -16640 (83360) \\\hline
- & 100703 (100703) & 33219 (33219) \\\hline
0000 1000 0000 0111 & 4007 (4007) & 2055 (2055) \\\hline
1111 1111 1101 0110 & -52 (36) & -42 (58) \\\hline
0000 0001 1111 0100 & 764 (764) & 500 (500) \\\hline
\end{tabular} 
\end{center}

Nebenrechnungen:

\begin{enumerate}
\item $0110\ 0110\ 1010\ 0110_2$

Ist positiv, entspricht also der gleichen Zahl im Einerkomplement.

Entspricht $0\ 110\ 011\ 010\ 100\ 110_2 = 6\ 3\ 2\ 4\ 6_8$ und\\
$-6*8^4+3*8^3+2*8^2+4*8^1+6 = 26278_{10}$.

\item $1011111100000000_2$

Entspricht $1011111100000000_2 - 1 = 1011 1110 1111 1111_2 \rightarrow 0100 0001 0000 0000_2$ im Einerkomplement.

Entspricht (analog zu oben) $-40400_8$ und\\
$-(2^14) + (2^8) = -16640_{10}$

\item $100703_8$

Entspricht $001\ 000\ 000\ 111\ 000\ 011_2$. Es ist nicht möglich, diese Zahl darzustellen, da sie 17bit bräuchte.

Entspricht $8^5 + 7*8^2+3 = 33219_{10}$.

\item $4007_8$

Entspricht $0000\ 100\ 000\ 000\ 111_2$ und $4*8^3 + 7 = 2055_{10}$.

\item $-42_{10}$

Die 42 entspricht $0000 0000 0010 1010_2$ im Binärsystem:\\
$42 / 2 = 21 \textrm{R} 0$\\
$21 / 2 = 10 \textrm{R} 1$\\
$10 / 2 = 5 \textrm{R} 0$\\
$5 / 2 = 2 \textrm{R} 1$\\
$2 / 2 = 1 \textrm{R} 0$\\
$1 / 2 = 0 \textrm{R} 1$\\
Invertiert: $1111 1111 1101 0101_2$ und somit $1111 1111 1101 0101_2 + 1 = 1111 1111 1101 0110_2$ im Zweierkomplement.

Im Oktalsystem entspricht sie $52_8$:\\
$42 / 8 = 5 \textrm{R} 2$\\
$5 / 8 = 0 \textrm{R} 5$

\item $500_{10}$

Entspricht $0000 0001 1111 0100_2$:\\
$500 / 2 = 250 \textrm{R} 0$\\
$250 / 2 = 125 \textrm{R} 0$\\
$125 / 2 = 62 \textrm{R} 1$\\
$62 / 2 = 31 \textrm{R} 0$\\
$31 / 2 = 15 \textrm{R} 1$\\
$15 / 2 = 7 \textrm{R} 1$\\
$7 / 2 = 3 \textrm{R} 1$\\
$3 / 2 = 1 \textrm{R} 1$\\
$1 / 2 = 0 \textrm{R} 1$

Entspricht $764_8$:\\
$500 / 8 = 62 \textrm{R} 4$\\
$62 / 8 = 7 \textrm{R} 6$\\
$7 / 8 = 0 \textrm{R} 7$
\end{enumerate}

\section*{3.3}
\subsection*{(a)}
Die Begriffe \textit{Casting} und \textit{Coercion} beziehen sich beide auf das Umwandeln von einem Typ in einen anderen, z.B. von einem Integer in ein Float. Bei \textit{Casting} passiert dies explizit, also z.B. durch das Anwenden von \verb+float()+ oder \verb+int()+, beim \textit{Coercion} implizit, z.B. durch das Addieren eines Integers zu einem Float wird der Integer implizit zu einem Float gecasted.
\subsection*{(b)}
Probleme treten insbesondere dann auf, wenn ein Typ nicht in den Zieltyp geschrieben werden kann. Z.B. kann der String \verb+"1.2"+ problemlos (explizit) zu einem Float gecastet werden, hingegen funktioniert dies bei dem String \verb+"Hello"+ nicht. Außerdem kann insbesondere beim Umwandeln von Floats in Integer die Präzision leiden, so wird \verb+int(1.2)+ zu \verb+1+.
\subsection*{(c)}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Python shell & Casting & Coercion & Nichts davon \\\hline\hline
\verb+>>> 3 * 3.14+ & & X & \\\hline
\verb+>>> int(float(str(ord(chr(123)))))+ & X & & \\\hline
\verb+>>> int (1 - - 1)+ & & & X \\\hline
\verb+>>> 4 << 1+ & & & X \\\hline
\end{tabular}
\end{center}
In der ersten Zeile handelt es sich um eine implizite Umwandlung vom Interger \verb+3+ zur Float \verb+3.0+.\\
In der zweiten Zeile wird der Integer \verb+123+ explizit zu einem Integer (mit Zwischentypen: String, Integer, String, Float) gecastet.\\
Der Ausdruck \verb+1--1+ in der dritten Zeile ist bereits ein Integer.\\
In der letzten Zeile wird nur eine Verschiebung des 3. (least-significant) Bits um eins nach links vorgenommen. Der Wert bleibt dabei ein Integer.